---
layout: post
title: 培训结束，我免费了
subtitle:  
date: 2020-10-13
author: Pacras
tags: 开心 
---
&nbsp; &nbsp; &nbsp; &nbsp; **北京的天是晴朗的天，通州的人民好喜欢。眼望丰台高声喊，我爱你海淀！**昨天实物检查，今天课题结束了，感觉一下子就轻松了。今天5点半下班就走了，去球馆看人家打球，然后和朴老师出来散步，**这就是我想要的生活啊！**

&nbsp; &nbsp; &nbsp; &nbsp; 由于也不知道课题能不能说，所以还是就谢谢最近遇到有意思的题吧。

## 1.[树中距离之和](https://leetcode-cn.com/problems/sum-of-distances-in-tree/)
&nbsp; &nbsp; &nbsp; &nbsp;这道题肯定不能一个个节点地去统计其与其他节点的距离之和。仔细想想的话，节点`i`与其父节点`j`存在着某种联系：`i`到`i`及其子树中每个节点的距离都比`j`少1，而到这些节点之外的节点的距离都要多1。而根节点到其他节点的距离之和就是树中节点的深度之和，之后在从上到下统计各节点即可。代码如下所示：

```python
class Solution:
    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:
        # 节点 i 通过其父亲节点 j 的距离之和计算自己的距离之和:
        
        # i 相比 j, 到自己的子节点（包括自己、以及子树的子树）的距离均要少1，但到其他节点的距离都要多1
        
        # 那么只要弄清楚：父子节点的对应关系  每个节点的子节点数

        # 建立节点间的对应关系
        
        tree = [[] for _ in range(N)]
        for parent, child in edges:
            tree[parent].append(child)
            tree[child].append(parent) 
        
        # 统计每个节点的深度以及子节点数量
        
        depth = [0] * N
        childs_count = [0] * N

        # 计算 node 的子节点数量
        
        def getDepthAndChildsCounts(parent, node):
            # 把自己加进来
            
            childs_count[node] = 1
            for c in tree[node]:
                # 排除父节点
                
                if c == parent:
                    continue
                # 子节点的深度等于父节点加一
                
                depth[c] = depth[node] + 1
                # 先把子节点的数量算出来，再加上
                
                getDepthAndChildsCounts(node, c)
                childs_count[node] += childs_count[c]

        # 计算各个节点的深度和子节点数量
        
        getDepthAndChildsCounts(-1, 0)

        res = [0] * N 
        res[0] = sum(depth)
        def getAnswer(parent, node):
            for c in tree[node]:
                if c == parent:
                    continue
                res[c] = res[node] + N - 2 * childs_count[c]
                getAnswer(node, c)
        getAnswer(-1, 0)
        return res

```

## 2.[分割两个字符串得到回文串](https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/)
&nbsp; &nbsp; &nbsp; &nbsp;这道题我的思路就是用指针`i`、`j`分别指向字符串`a`的头和`b`的尾，如果`a[i] == b[j]`且`a[i+1:j]`是回文串或者`b[i+1:j]`是回文串，则返回True即可。当然需要把`a`、`b`位置互换再来一次。但是这样做超时了。最后参考了大佬的思路，利用不能构成回文串的条件来做：

```python
class Solution:
    def checkPalindromeFormation(self, a: str, b: str) -> bool:        
        length = len(a)
        for i in range(length):
            if i == length//2 and a[i] == b[-i-1]:
                return True
            # 找到了不能构成回文串的必要条件

            if a[i] != b[-i-1] and b[i] != a[-i-1] and a[i] != a[-i-1] and b[i] != b[-i-1]:
                return False
        return True
```




